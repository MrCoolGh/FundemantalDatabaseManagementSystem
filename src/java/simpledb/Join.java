package simpledb;

import java.util.*;

/**
 * The Join operator implements the relational join operation.
 */
public class Join extends Operator {

    private static final long serialVersionUID = 1L;

    JoinPredicate joinP;
    OpIterator[] childOps = new OpIterator[2];

    // for hash equal join in case first field has some tuple with same key
    Hashtable<Field, ArrayList<Tuple>> hashJoinTable = new Hashtable<>();
    int sameFieldCount = 0;
    ArrayList<Tuple> currentTupleGroup = new ArrayList<>();
    Tuple pastT2 = null;

    Tuple pastT1 = null;



    /**
     * Constructor. Accepts two children to join and the predicate to join them
     * on
     * 
     * @param p
     *            The predicate to use to join the children
     * @param child1
     *            Iterator for the left(outer) relation to join
     * @param child2
     *            Iterator for the right(inner) relation to join
     */
    public Join(JoinPredicate p, OpIterator child1, OpIterator child2) {
        // some code goes here
        this.joinP = p;
        this.childOps[0] = child1;
        this.childOps[1] = child2;

    }

    public JoinPredicate getJoinPredicate() {
        // some code goes here
        return this.joinP;
    }

    /**
     * @return
     *       the field name of join field1. Should be quantified by
     *       alias or table name.
     * */
    public String getJoinField1Name() {
        // some code goes here
        int id1 = this.joinP.getField1();
        return this.childOps[0].getTupleDesc().getFieldName(id1);
    }

    /**
     * @return
     *       the field name of join field2. Should be quantified by
     *       alias or table name.
     * */
    public String getJoinField2Name() {
        // some code goes here
        int id2 = this.joinP.getField2();
        return this.childOps[1].getTupleDesc().getFieldName(id2);
    }

    /**
     * @see simpledb.TupleDesc#merge(TupleDesc, TupleDesc) for possible
     *      implementation logic.
     */
    public TupleDesc getTupleDesc() {
        // some code goes here
        return TupleDesc.merge(this.childOps[0].getTupleDesc(), this.childOps[1].getTupleDesc());
    }

    public void open() throws DbException, NoSuchElementException,
            TransactionAbortedException {
        // some code goes here
        super.open();
        this.childOps[0].open();
        while (this.childOps[0].hasNext()) {
            Tuple nextTuple = this.childOps[0].next();
            if (hashJoinTable.containsKey(nextTuple.getField(joinP.getField1()))){
                ArrayList<Tuple> tupleArr = hashJoinTable.get(nextTuple.getField(joinP.getField1()));
                tupleArr.add(nextTuple);
                hashJoinTable.put(nextTuple.getField(joinP.getField1()),tupleArr);
            } else {
                ArrayList<Tuple> newTupleList = new ArrayList<>();
                newTupleList.add(nextTuple);
                hashJoinTable.put(nextTuple.getField(joinP.getField1()), newTupleList);
            }
        }
        this.childOps[1].open();

    }

    public void close() {
        // some code goes here
        super.close();
        this.childOps[0].close();
        this.childOps[1].close();
    }

    public void rewind() throws DbException, TransactionAbortedException {
        // some code goes here
        this.childOps[0].rewind();
        this.childOps[1].rewind();
        sameFieldCount = 0;
        currentTupleGroup = new ArrayList<>();
        pastT2 = null;
    }

    /**
     * Returns the next tuple generated by the join, or null if there are no
     * more tuples. Logically, this is the next tuple in r1 cross r2 that
     * satisfies the join predicate. There are many possible implementations;
     * the simplest is a nested loops join.
     * <p>
     * Note that the tuples returned from this particular implementation of Join
     * are simply the concatenation of joining tuples from the left and right
     * relation. Therefore, if an equality predicate is used there will be two
     * copies of the join attribute in the results. (Removing such duplicate
     * columns can be done with an additional projection operator if needed.)
     * <p>
     * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
     * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
     * 
     * @return The next matching tuple.
     * @see JoinPredicate#filter
     */
    protected Tuple fetchNext() throws TransactionAbortedException, DbException {
        // some code goes here
        if (this.joinP.getOperator() == Predicate.Op.EQUALS) {
            // hash table join for equal join
            if (this.sameFieldCount < this.currentTupleGroup.size()) {
                //Use the saved group to pair up in case of of multiple tuple in 1 has same key
                Tuple r1Next = currentTupleGroup.get(sameFieldCount);
                sameFieldCount++;
                return combineTuple(r1Next, this.pastT2);
            } else {
                sameFieldCount = 0;
                while (this.childOps[1].hasNext()) {
                    Tuple r2Next = this.childOps[1].next();
                    Field key = r2Next.getField(this.joinP.getField2());
                    // exist the match in hash table
                    if (this.hashJoinTable.get(key) != null) {
                        //save to currentTupleGroup
                        this.currentTupleGroup = this.hashJoinTable.get(key);
                        //save the past 2
                        this.pastT2 = r2Next;
                        Tuple r1Next = currentTupleGroup.get(sameFieldCount);
                        sameFieldCount++;
                        return combineTuple(r1Next, r2Next);
                    }
                }
            }

        } else {
            while (this.childOps[0].hasNext()) {
                if (pastT1 == null || !this.childOps[1].hasNext()) {
                    pastT1 = this.childOps[0].next();
                    this.childOps[1].rewind();
                }
                while (this.childOps[1].hasNext()) {
                    Tuple t2 = this.childOps[1].next();
                    if (joinP.filter(pastT1,t2)) {
                        return combineTuple(pastT1,t2);
                    }
                }
            }
        }
        this.currentTupleGroup = new ArrayList<>(this.sameFieldCount);
        return null;
    }

    public Tuple combineTuple(Tuple t1, Tuple t2) {
        TupleDesc t1Desc = t1.getTupleDesc();
        TupleDesc t2Desc = t2.getTupleDesc();
        TupleDesc combineDesc = TupleDesc.merge(t1Desc,t2Desc);
        Tuple result = new Tuple(combineDesc);
        int i = 0;
        Iterator<Field> t1Iterator = t1.fields();
        while(t1Iterator.hasNext()) {
            result.setField(i, t1Iterator.next());
            i++;
        }
        Iterator<Field> t2Iterator = t2.fields();
        while (t2Iterator.hasNext()) {
            result.setField(i, t2Iterator.next());
            i++;
        }
        return result;
    }

    @Override
    public OpIterator[] getChildren() {
        // some code goes here
        return this.childOps;
    }

    @Override
    public void setChildren(OpIterator[] children) {
        // some code goes here
        this.childOps = children;
    }

}
